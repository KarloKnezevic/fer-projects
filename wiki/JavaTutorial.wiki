#summary Kratki vodič kroz Javu i OOP uz jednostavan primjer

= Uvod =

Euclid is said to have replied to King Ptolemy's request for an easier way of learning mathematics:
     "_There is no royal road to geometry._"


Ne postoji sličan put ni za ovo. Pokušat ću vam kroz primjere što efikasnije prenjeti neke ideje o OOP i Javi ali morat ćete i sami uključiti mozak. Nisam Java guru ali to nije toliko ni bitno.

Sintaksa Jave i mogućnosti samog jezika su poprilično jednostavne i prelazak sa C-a što se toga tiče nije težak. No bitno je i razumijevanje ideja OOP-a, poznavanje standardnih biblioteka, poznavanje raznih alata.

= Mu =

Krenimo od početka. Otvorite Eclipse i stvorite novi Java projekt: File -> New -> Java project. Tradicionalno nazovite projekt "Hello World". JRE neka bude verzije 1.6, i izaberite ono "Create separate folders for sources and class files". Kliknite finish. U vašem _workspaceu_ će se stvoriti direktorij "Hello World" i u njemu još dva direktorija: `src` i `bin` -- u `src` se nalazi vaš kod, a u `bin` kompajlirane Java datoteke (`.class`) koje su spremene za izvršavanje na JVM-u. Svaki put kad "sejvate" (`Ctrl-S`) kod Eclipse ga automatski kompajlira.

Sad kliknite desnim klikom na projekt i izaberite: New -> Package. Što je *package*? U drugim jezicima se možete susresti s nazivom _namespace_. To je jedna te ista stvar. Ovaj drugi naziv je puno sugestivniji. Ideja je jednostava: može se dogoditi da dva razreda (eng. class, doći ćemo do toga) imaju _isto ime_ pa mora postojati način da ih razlikujemo -- pogotovo ako ih oboje želimo koristiti. Razlikovat će se ako se nalaze u različitom paketu (packege/namespace). A i očito pomoću njih možemo bolje organizirati naš kod.

Za ime paketa stavite: `hr.fer.hello` -- u direktoriju `src` će nastati ovakva struktura direktorija: `src/hr/fer/hello` i sav kod iz paketa `hr.fer.hello` će se nalaziti u direktoriju `hello`. 

Sad desni klik na taj novonastali prazni paket i izaberite: New -> Class. Za ime upište `HelloWorld` (_konvencija_ je takva da se imena razreda uvijek započinju velikim slovom i da se koristi [http://en.wikipedia.org/wiki/Camelcase CamelCase], imena metoda započinjite malim slovom.) Izaberite dolje da želite da vam stvori `public static void main(String[] args)` "method stub". Finish.

Hop! Stvorio se nekakav prozor i kod u njemu. Primjetite komentare koji se jednako pišu kao u C-u. Izbrište ih pa bi trebali dobiti samo ovo:
{{{
package hr.fer.hello;

public class HelloWorld {

	public static void main(String[] args) {

	}

}
}}}

== Razredi i objekti ==
Krenimo od prve linije. Ona označava u kojem se paketu nalazi ova klasa/razred. Ali što je to uopće *razred* tj. *class*? Paaaa, sjetite se onog `struct` iz C-a. On nam je omogućio da stvaramo složenije tipove podataka (strukture) koji se sastoje od primitivnih (`int`, `float`...) ili od drugih složenih. Npr. željeli smo imati tip podataka `Tocka` koji se zapravo sastoji od x i y koordinate tj. od dva `float`-a. 

Ideja razreda i objekta je slična ideji `struct`-a ali mnogo moćnija i više razrađena. U C-u bi definirali novu strukturu sa:
{{{
struct Tocka {
	float x;
	float y;
};
}}}
A u Javi bi sličnu stvar napravili ovako:
{{{
class Tocka {
	float x;
	float y;
}
}}}
I hej! Pa to je skoro isto :) U C-u smo zatim obično imali nekakve funkcije koje su "operirale" nad našim strukturama. Primjerice, željeli smo funkciju koja će nam vratiti razliku x-a i y-a neke točke:
{{{ 
float razlika_x_y(struct Tocka * tocka) { return tocka->x - tocka->y }; 
}}}
Ta funkcija bi se nalazila negdje u kodu i kad bi je pozivali morali bi joj predati pokazivač na našu varijablu tipa `struct Tocka`.
Tu dolazimo do prve važne ideje OOP-a! 
Funkcije koje operiraju nad `Tocka`-ma će postati dio razreda `Tocka` i nazivat ćemo ih *metode*. Evo kako bi to izgledalo u Javi:
{{{
class Tocka {
	float x;
	float y;
	float razlika() { return this.x - this.y };
}
}}}
Kako bi sad koristili tu metodu? Evo isječak koda:
{{{
Tocka mu = new Tocka(); // Tocka je razred, a mu je referenca na objekt koji je _instanca_ tog razreda
mu.x = 10;
mu.y = 21;
float d = mu.razlika(); // metodi pristupamo jednako kao atributima (x i y) objekta, d će poprimiti vrijednost -11
}}}

Primjetite onaj misteričan `this` koji smo koristili u metodi `razlika()`. To je Java za nas implicitno prosljedila funkciji `razlika()` tu varijablu. Ona je referenca (kao što je `mu`) na objekt nad kojim želimo operirati s tom metodom. U C-u smo u suštini istu stvar radili _ručno_ -- pozvali bi funkciju i jedan od parametara bi bio pokazivač na strukturu. U OO jezicima se to događa u pozadini, implicitno, kad napišemo `mu.razlika()`. 

Dakle, vidimo da se razred/class sastoji od atributa (npr. x i y) i metoda (npr. razlika). Razred je kao _nacrt_ (blueprint) po kojem se gradi objekt. Odnosno, objekt je samo jedna od instanci nekog razreda. 

Idemo sad dalje pa ćemo vidjeti ostale ideje OOP-a.

== print Hello World; ==

Izmjenimo malo kod:
{{{
package hr.fer.hello;

public class HelloWorld {

	public static void main(String[] args) {
		for(int k=0; k<100; k++) System.out.print("Hello World!");
	}

}
}}}
Vidimo da je petlja `for` ista kao u C-u. `System.out` predstavlja standardni izlaz i jedna od metoda koje posjeduje je i ova `print` koja služi za ispis.

Program pokrenite na način da kliknete na onaj zeleni "play" gumbić ili Run -> Run ili `Ctrl-F11`. Ispisat će se 100 puta Hello World -- tko bi rekao.
Java kad pokreće vaš program uvijek potraži metodu `main()` i nju pozove. Main dobije polje Stringova `args` slično kao u C-u. To su npr. paramteri s kojima je program pozvan.

Main metoda ne vraća ništa pa zato piše `void` ali što znači ovo `public` i `static`?
Public označava *scope* (vidljivost) atributa/metode -- ako je `public` onda mu svi mogu pristupiti ako je primjerice `private` onda mu možete prisupiti samo unutar razreda. Npr.
{{{
class Razred { private int x; }
...
Razred r = new Razred();
int a = r.x; // ups! neće ići...
}}}
A za static:
  `static` variables and methods might better have been called perClass variables (_atributi, op.a._) and methods. They inherited this misleading terminology from C++. *They are the opposite of instance variables and methods that work on a particular object.*
  There is nothing static (unchanging) about them. They don’t cling. They are perfectly clear, unlike radio signals garbled by static.
  They are allocated when the class is loaded. *static refers to a method or variable that is not attached to a particular object, but rather to the class as a whole*. 

To za posljedicu ima da unutar `static` metode možete pozivati samo druge `static` metode i pristupati drugim `static` atributima. Jer `static` metodi uopće nije predan `this`! pošto ona ni ne pripada nekom određenom objektu već samo razredu. Evo primjer sa našim HelloWorld razredom, isječak:
{{{
HelloWorld hw = new HelloWorld();
hw.main(null); // ups! neće ići, hw je referenca na objekt i on sam ne sadrži metodu main
HelloWorld.main(null); // to je već bolje ;)
}}}
Primjetite ovo `null` -- metoda main prima referencu na polje Stringova, no mi smo joj predali samo `null` vrijednost odnosno referencu koja ne pokazuje nigdje.

== Idemo dalje! ==
Do sad bi trebali razumijeti pojmove poput razreda (class), objekta, metode, atributa, `public`, `static`. Idemo proširiti naš primjer.

Dodajte u naš paket `hr.fer.hello` razred `Stvorenje` (ovaj put bez `main` metode). Neka ima atribute `starost` tipa `int` i `umnost` tipa `boolean`. Oba atributa neka budu `private`. Dodat ćemo mu još neke stvari, evo kako konačno izgleda razred:
{{{
package hr.fer.hello;

public class Stvorenje {

	private int starost;
	private boolean umnost;
	
	public Stvorenje(int starost, boolean umnost) {
		this.starost = setStarost(starost);
		this.umnost = umnost; // ovdje koristimo this jer inace ne bi bilo jasno na sto mislimo
	}

	public int getStarost() {
		return starost;
	}

	public void setStarost(int starost) throws Exception {
		if(starost < 0) throw new Exception("Starost mora biti pozitivna!");
		this.starost = starost;
	}

	public boolean isUmnost() {
		return umnost; // ovdje nam this ne treba jer je jasno na koju umnost mislimo - na this.umnost
	}

	public void setUmnost(boolean umnost) {
		this.umnost = umnost;
	}	
}
}}}

Atributi starost i umnost su private pa im ne možemo pristupiti izvana -- zato imamo metode koje će nam služiti za pristup njihovim vrijednostima tzv. getteri i setteri. To je u Javi često praksa. Jedna od prednosti je upravo ovo što smo učinili unutar metode `setStarost` -- prije nego što postavimo starost provjerimo je li nenegativna. Ako nije onda prekinemo tok izvođenja s nečim što se zove *Exception*. O tome više sami saznajte sad nije bitno.

Takva praksa ima i drugih prednosti koje možda sad nisu očite. Naravno, nedostatak je povecana kolicina koda odnosno verboznost.

Još jedna nova stvar je ova metoda `public Stvorenje(int starost, boolean umnost)` -- to je tzv. *konstruktor* i kad radimo instancu ovog razreda onda se on prvi poziva. Pogledajmo to u modificranom `HelloWorld` razredu:
{{{
package hr.fer.hello;

import java.util.Set;

public class HelloWorld {

	public static void main(String[] args) {
		Set<Stvorenje> zivotinjskoCarstvo = new java.util.HashSet<Stvorenje>();
		
		for(int k=0; k<10; k++) {
			zivotinjskoCarstvo.add(new Stvorenje(k, true)); // stvaramo i dodajemo u set novi objekt i prilikom stvaranja pozvat ce se spomenuti konstruktor s parametrima k i true
		}
		for(int k=0; k<10; k++) {
			zivotinjskoCarstvo.add(new Stvorenje(k, false));
		}
		
		for(Stvorenje stvor : zivotinjskoCarstvo) {
			if(stvor.isUmnost()) {
				System.out.print(stvor.getStarost());
			}
		}	
	}
}
}}}
